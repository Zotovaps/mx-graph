<!--
  Copyright (c) 2006-2015, JGraph Ltd
  
  Scrollbars example for mxGraph. This example demonstrates using
  a scrollable table with different sections in a cell label.
-->
<html>
<head>
    <title>Scrollbars example for mxGraph</title>

    <style type="text/css" media="screen">
        ::-webkit-scrollbar {
            width: 4px; /* width of the entire scrollbar */
            height: 10px; /* width of the entire scrollbar */
        }

        ::-webkit-scrollbar-track {
            background: #E8EAF1;; /* color of the tracking area */
        }

        ::-webkit-scrollbar-thumb {
            background-color: #B7BDD0; /* color of the scroll thumb */
            border-radius: 20px; /* roundness of the scroll thumb */
            /*border: 3px solid orange; !* creates padding around scroll thumb *!*/
        }


        table.title {
            border-color: black;
            border-collapse: collapse;
            cursor: move;
            height: 26px;
            border-bottom-style: none;
            color: black;
        }

        table.title th {
            font-size: 10pt;
            font-family: Verdana;
            white-space: nowrap;
            background: lightgray;
            font-weight: bold;
        }

        table.erd {
            font-size: 10pt;
            font-family: Verdana;
            border-color: black;
            border-collapse: collapse;
            overflow: auto;
            cursor: move;
            white-space: nowrap;

            border: none !important;
        }

        table.erd td {
            border-color: black;
            text-align: left;
            color: black;

            padding: 4px;

        }

        button {
            position: absolute;
        }
    </style>

    <!-- Sets the basepath for the library if not in same directory -->
    <script type="text/javascript">
        mxBasePath = '../src';
    </script>

    <!-- Loads and initializes the library -->
    <script type="text/javascript" src="../src/js/mxClient.js"></script>

    <!-- Example code -->
    <script type="text/javascript">
        // Program starts here. Creates a sample graph in the
        // DOM node with the specified ID. This function is invoked
        // from the onLoad event handler of the document (see below).
        function main(container) {
            // Checks if the browser is supported
            if (!mxClient.isBrowserSupported()) {
                // Displays an error message if the browser is not supported.
                mxUtils.error('Browser is not supported!', 200, false);
            } else {
                // Must be disabled to compute positions inside the DOM tree of the cell label.
                mxGraphView.prototype.optimizeVmlReflows = false;

                // If connect preview is not moved away then getCellAt is used to detect the cell under
                // the mouse if the mouse is over the preview shape in IE (no event transparency), ie.
                // the built-in hit-detection of the HTML document will not be used in this case. This is
                // not a problem here since the preview moves away from the mouse as soon as it connects
                // to any given table row. This is because the edge connects to the outside of the row and
                // is aligned to the grid during the preview.
                mxConnectionHandler.prototype.movePreviewAway = false;

                // Disables foreignObjects
                mxClient.NO_FO = true;

                // Enables move preview in HTML to appear on top
                mxGraphHandler.prototype.htmlPreview = true;

                // Enables connect icons to appear on top of HTML
                mxConnectionHandler.prototype.moveIconFront = true;

                // Defines an icon for creating new connections in the connection handler.
                // This will automatically disable the highlighting of the source vertex.
                mxConnectionHandler.prototype.connectImage = new mxImage('images/connector.gif', 16, 16);

                // Support for certain CSS styles in quirks mode
                if (mxClient.IS_QUIRKS) {
                    new mxDivResizer(container);
                }

                // Disables the context menu
                mxEvent.disableContextMenu(container);

                // // Overrides target perimeter point for connection previews
                // mxConnectionHandler.prototype.getTargetPerimeterPoint = function (state, me) {
                //     // Determines the y-coordinate of the target perimeter point
                //     // by using the currentTdNode assigned in updateRow
                //     debugger
                //     var y = me.getY();
                //
                //     if (this.currentTdNode != null) {
                //         y = getRowY(state, this.currentTdNode);
                //     }
                //
                //     // Checks on which side of the terminal to leave
                //     var x = state.x;
                //
                //     if (this.previous.getCenterX() > state.getCenterX()) {
                //         x += state.width;
                //     }
                //
                //     return new mxPoint(x, y);
                // };
                //
                // // Overrides source perimeter point for connection previews
                // mxConnectionHandler.prototype.getSourcePerimeterPoint = function (state, next, me) {
                //     debugger
                //     var y = me.getY();
                //
                //     if (this.sourceTdNode != null) {
                //         y = getRowY(state, this.sourceTdNode);
                //     }
                //
                //     // Checks on which side of the terminal to leave
                //     var x = state.x;
                //
                //     if (next.x > state.getCenterX()) {
                //         x += state.width;
                //     }
                //
                //     return new mxPoint(x, y);
                // };

                // Disables connections to invalid rows
                mxConnectionHandler.prototype.isValidTarget = function (cell) {
                    return this.currentTdNode != null;
                };

                // Creates the graph inside the given container
                var graph = new mxGraph(container);

                // Uses the entity perimeter (below) as default
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_PERIMETER] = mxPerimeter.EntityPerimeter;
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_SHADOW] = true;
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_FILLCOLOR] = '#DDEAFF';
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_GRADIENTCOLOR] = '#A9C4EB';
                delete graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_STROKECOLOR];

                // Used for HTML labels that use up the complete vertex space (see
                // graph.cellRenderer.redrawLabel below for syncing the size)
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_OVERFLOW] = 'fill';

                // Uses the entity edge style as default
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_STROKECOLOR] = 'black';
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_FONTCOLOR] = 'black';

                // Allows new connections to be made but do not allow existing
                // connections to be changed for the sake of simplicity of this
                // example
                graph.setCellsDisconnectable(false);
                graph.setAllowDanglingEdges(false);
                graph.setCellsEditable(false);
                graph.setConnectable(true);
                graph.setPanning(true);
                graph.centerZoom = false;

                // Override folding to allow for tables
                graph.isCellFoldable = function (cell, collapse) {
                    return this.getModel().isVertex(cell);
                };

                // Overrides connectable state
                graph.isCellConnectable = function (cell) {
                    return !this.isCellCollapsed(cell);
                };

                // Enables HTML markup in all labels
                graph.setHtmlLabels(true);

                // Scroll events should not start moving the vertex
                graph.cellRenderer.isLabelEvent = function (state, evt) {
                    var source = mxEvent.getSource(evt);

                    return state.text != null && source != state.text.node &&
                        source != state.text.node.getElementsByTagName('div')[0];
                };

                // Adds scrollbars to the outermost div and keeps the
                // DIV position and size the same as the vertex
                var oldRedrawLabel = graph.cellRenderer.redrawLabel;
                graph.cellRenderer.redrawLabel = function (state) {
                    oldRedrawLabel.apply(this, arguments); // "supercall"
                    var graph = state.view.graph;
                    var model = graph.model;

                    if (model.isVertex(state.cell) && state.text != null) {
                        // Scrollbars are on the div
                        var s = graph.view.scale;
                        var div = state.text.node.getElementsByTagName('div')[2];

                        if (div != null) {
                            // Installs the handler for updating connected edges
                            if (div.scrollHandler == null) {
                                div.scrollHandler = true;

                                var updateEdges = mxUtils.bind(this, function () {
                                    var edgeCount = model.getEdgeCount(state.cell);

                                    // Only updates edges to avoid update in DOM order
                                    // for text label which would reset the scrollbar
                                    for (var i = 0; i < edgeCount; i++) {
                                        var edge = model.getEdgeAt(state.cell, i);
                                        graph.view.invalidate(edge, true, false);
                                        graph.view.validate(edge);
                                    }
                                });

                                mxEvent.addListener(div, 'scroll', updateEdges);
                                mxEvent.addListener(div, 'mouseup', updateEdges);
                            }
                        }
                    }
                };

                // Adds a new function to update the currentRow based on the given event
                // and return the DOM node for that row
                graph.connectionHandler.updateTd = function (target) {
                    while (target != null && target.nodeName != 'TD') {
                        target = target.parentNode;
                    }

                    this.currentTd = null;

                    // Checks if we're dealing with a row in the correct table
                    if (getParentDiv(target) && target.getAttribute("box_id") !== 'undefined') {
                        this.currentTd = target.getAttribute("box_id");
                    } else {
                        target = null;
                    }

                    return target;
                };

                // Adds placement of the connect icon based on the mouse event target (row)
                graph.connectionHandler.updateIcons = function (state, icons, me) {
                    var target = me.getSource();
                    target = this.updateTd(target);
                    if (target != null && this.currentTd != null) {
                        var div = getParentDiv(target)
                        var offsetValues = getOffsetValues(target, div)
                        var s = state.view.scale;

                        icons[0].node.style.visibility = 'visible';
                        icons[0].bounds.x = state.x + offsetValues.x * s + Math.min(state.width, target.offsetWidth * s) - this.icons[0].bounds.width - 2;
                        icons[0].bounds.y = state.y - this.icons[0].bounds.height / 2 + (offsetValues.y + target.offsetHeight / 2 - div.scrollTop + div.offsetTop) * s;

                        icons[0].bounds.width = 16 * s;
                        icons[0].bounds.height = 16 * s;

                        icons[0].redraw();

                        this.currentTdNode = target;
                    } else {
                        icons[0].node.style.visibility = 'hidden';
                    }
                };

                // Updates the targetRow in the preview edge State
                var oldMouseMove = graph.connectionHandler.mouseMove;
                graph.connectionHandler.mouseMove = function (sender, me) {
                    if (this.edgeState != null) {
                        this.currentTdNode = this.updateTd(me.getSource());
                        if (this.currentTd != null) {
                            this.edgeState.cell.value.setAttribute('targetTd', this.currentTd);
                        } else {
                            this.edgeState.cell.value.setAttribute('targetTd', '0');
                        }

                        // Destroys icon to prevent event redirection via image in IE
                        this.destroyIcons();
                    }

                    oldMouseMove.apply(this, arguments);
                };

                // Creates the edge state that may be used for preview
                graph.connectionHandler.createEdgeState = function (me) {
                    var relation = doc.createElement('Relation');
                    relation.setAttribute('sourceTd', this.currentTd || '0');
                    relation.setAttribute('targetTd', '0');

                    var edge = this.createEdge(relation);
                    var style = this.graph.getCellStyle(edge);
                    var state = new mxCellState(this.graph.view, edge, style);

                    // Stores the source row in the handler
                    this.sourceTdNode = this.currentTdNode;

                    return state;
                };

                // Overrides getLabel to return empty labels for edges and
                // short markup for collapsed cells.
                graph.getLabel = function (cell) {
                    if (this.getModel().isVertex(cell)) {
                        if (this.isCellCollapsed(cell)) {
                            return cell.collapsedValue;
                        } else {
                            return cell.value;
                        }
                    } else {
                        return '';
                    }
                };

                // User objects (data) for the individual cells
                var doc = mxUtils.createXmlDocument();

                // Same should be used to create the XML node for the table
                // description and the rows (most probably as child nodes)
                // var relation = doc.createElement('Relation');
                // relation.setAttribute('sourceRow', '2');
                // relation.setAttribute('targetRow', '6');

                // Enables rubberband selection
                new mxRubberband(graph);

                // Enables key handling (eg. escape)
                new mxKeyHandler(graph);

                // Gets the default parent for inserting new cells. This
                // is normally the first child of the root (ie. layer 0).
                var parent = graph.getDefaultParent();

                // Adds cells to the model in a single step
                var width = 160;
                var height = 230;
                graph.getModel().beginUpdate();
                try {
                    var v1 = graph.insertVertex(parent, null, '', 20, 20, width, height);
                    v1.caption = "Test"
                    v1.body = {
                        "rows": [
                            {
                                "columns": [
                                    {
                                        "item": {
                                            "box_id": "item1",
                                            "caption": "aaa"
                                        }
                                    },
                                    {
                                        "rows": [
                                            {
                                                "columns": [
                                                    {
                                                        "item": {
                                                            "box_id": "item2",
                                                            "caption": "222"
                                                        }
                                                    }
                                                ]

                                            },
                                            {
                                                "columns": [
                                                    {
                                                        "item": {
                                                            "box_id": "item3",
                                                            "caption": "333"
                                                        }
                                                    }
                                                ]

                                            },
                                            {
                                                "columns": [
                                                    {
                                                        "item": {
                                                            "box_id": "itemopopo",
                                                            "caption": "444"
                                                        }
                                                    }
                                                ]

                                            },
                                        ]
                                    }
                                ]
                            },
                            {
                                "columns": [
                                    {
                                        "item": {
                                            "box_id": "item4",
                                            "caption": "ddd"
                                        }
                                    },
                                    {
                                        "item": {
                                            "caption": "eee"
                                        }
                                    },
                                    {
                                        "rows": [
                                            {
                                                "columns": [
                                                    {
                                                        "item": {
                                                            "box_id": "itemqw",
                                                            "caption": "222"
                                                        }
                                                    }
                                                ]

                                            },
                                            {
                                                "columns": [
                                                    {
                                                        "item": {
                                                            "box_id": "itemer",
                                                            "caption": "333"
                                                        }
                                                    }
                                                ]

                                            },
                                            {
                                                "columns": [
                                                    {
                                                        "item": {
                                                            "box_id": "itemty",
                                                            "caption": "444"
                                                        }
                                                    }
                                                ]

                                            },
                                        ]
                                    }
                                ]
                            },
                            {
                                "columns": [
                                    {
                                        "item": {
                                            "box_id": "item7",
                                            "caption": "ggg"
                                        }
                                    },
                                    {
                                        "item": {
                                            "box_id": "item8",
                                            "caption": "hhh"
                                        }
                                    },
                                    {
                                        "item": {
                                            "box_id": "item9",
                                            "caption": "kkk"
                                        }
                                    }
                                ]
                            }
                        ]
                    }
                    v1.id = "box_rows_columns_example";
                    v1.geometry.alternateBounds = new mxRectangle(0, 0, width, 26);
                    v1.value = createTableHTML(v1)
                    v1.collapsedValue = createCollapsedTableHTML(v1)


                    var v2 = graph.insertVertex(parent, null, '', 400, 150, width, height);
                    v2.caption = "Customers"
                    v2.geometry.alternateBounds = new mxRectangle(0, 0, width, 26);
                    v2.value = `<table style="overflow:hidden;" width="100%" border="1" cellpadding="4" class="title"><tr><th colspan="2">${v2.caption}</th></tr></table><div style="overflow:auto;cursor:default;top:26px;bottom:0px;position:absolute;width:100%;"><table width="100%" height="100%" border="1" cellpadding="4" class="erd"><tr><td box_id="box1">123</td><td box_id="box2"><u>customerId</u></td></tr><tr><td box_id="box3"></td><td box_id="box4">number</td></tr><tr><td box_id="box5"></td><td box_id="box6">firstName</td></tr><tr><td box_id="box7"></td><td box_id="box8">lastName</td></tr><tr><td box_id="box9"></td><td box_id="box10">streetAddress</td></tr><tr><td box_id="box11"></td><td box_id="box12">city</td></tr><tr><td box_id="box13"></td><td box_id="box14">state</td></tr><tr><td box_id="box15"></td><td box_id="box16">zip</td></tr></table></div>`
                    v2.collapsedValue = createCollapsedTableHTML(v2)

                    // graph.insertEdge(parent, null, relation, v1, v2);
                } finally {
                    // Updates the display
                    graph.getModel().endUpdate();
                }

                function createTableHTML(cell) {
                    const container = document.createElement("div")

                    const tableHeader = createCollapsedTableHTML(cell)
                    const div = document.createElement("div")
                    div.setAttribute("style", 'overflow:auto;cursor:default;top:26px;bottom:0px;position:absolute;width:100%;')
                    const tableBody = document.createElement("table")
                    tableBody.setAttribute("width", "100%")
                    tableBody.setAttribute("height", "100%")
                    tableBody.setAttribute("class", "erd")

                    const tbody = document.createElement("tbody")

                    cell.body.rows.forEach(row => {
                        const tr = document.createElement("tr")
                        row.columns.forEach(column => {

                            if (column.rows) {
                                const td2 = document.createElement("td")
                                const tableBody2 = document.createElement("table")
                                tableBody2.setAttribute("width", "100%")
                                tableBody2.setAttribute("height", "100%")
                                tableBody2.setAttribute("border", "1")
                                tableBody2.setAttribute("cellpadding", "4")
                                tableBody2.setAttribute("class", "erd")

                                const tbody2 = document.createElement("tbody")

                                column.rows.forEach(r => {
                                    const tr2 = document.createElement("tr")

                                    r.columns.forEach(c => {
                                        const td2 = document.createElement("td")
                                        td2.setAttribute("box_id", c.item.box_id)
                                        td2.innerText = c.item.caption
                                        tr2.appendChild(td2)
                                    })

                                    tbody2.appendChild(tr2)

                                })
                                tableBody2.appendChild(tbody2)
                                td2.appendChild(tableBody2)
                                tr.appendChild(td2)
                            }
                            else {
                                const td = document.createElement("td")
                                td.setAttribute("box_id", column.item.box_id)
                                td.innerText = column.item.caption
                                tr.appendChild(td)
                            }

                        })
                        tbody.appendChild(tr)
                    })

                    tableBody.appendChild(tbody)
                    div.appendChild(tableBody)
                    container.appendChild(tableHeader)
                    container.appendChild(div)

                    return container.innerHTML
                }

                function createCollapsedTableHTML(cell) {
                    const table = document.createElement("table")
                    table.setAttribute("style", "overflow:hidden;")
                    table.setAttribute("width", "100%")
                    table.setAttribute("height", "100%")
                    table.setAttribute("border", "1")
                    table.setAttribute("cellpadding", "4")
                    table.setAttribute("class", "title")
                    const tbody = document.createElement("tbody")
                    const tr = document.createElement("tr")
                    const th = document.createElement("th")
                    th.innerText = cell.caption

                    tr.appendChild(th)
                    tbody.appendChild(tr)
                    table.appendChild(tbody)

                    return table
                }

                var btn1 = mxUtils.button('+', function () {
                    graph.zoomIn();
                });
                btn1.style.marginLeft = '20px';

                document.body.appendChild(btn1);
                document.body.appendChild(mxUtils.button('-', function () {
                    graph.zoomOut();
                }));

                document.getElementById("log_button").onclick = () => {
                    const dict = new Object()
                    const json = new Object()
                    json.boxes = []
                    const arrayCells = graph.getChildVertices(graph.defaultParent)

                    arrayCells.forEach(cell => {
                        const box = new Object()
                        box.id = cell.id
                        box.header = new Object()
                        box.header.position = new Object()
                        box.header.size = new Object()
                        box.header.position.left = cell.geometry.x
                        box.header.position.top = cell.geometry.y
                        box.header.size.width = cell.geometry.width
                        box.header.size.height = cell.geometry.height

                        const tmpDiv = document.createElement("div")
                        tmpDiv.innerHTML = cell.value

                        box.header.caption = tmpDiv.querySelector("table.title> tbody > tr > th").innerText


                        if (tmpDiv.querySelector("table.erd> tbody").children.length > 0) {
                            box.body = new Object()
                            box.body.rows = []
                            for (const tr of tmpDiv.querySelector("table.erd> tbody").children) {
                                const row = new Object()
                                row.columns = []

                                for (const td of tr.children) {
                                    const column = recursiveRows(td, dict)

                                    row.columns.push(column)
                                }

                                box.body.rows.push(row)
                            }
                        }

                        for (const edge of cell.edges.filter(e => e.source === cell)) {
                            const sourceId = edge.value.getAttribute("sourceTd")
                            const targetId = edge.value.getAttribute("targetTd")


                            if (dict[sourceId].box_links) {
                                dict[sourceId].box_links.push({
                                    link: {
                                        typelink: 2,
                                        box_id: `${edge.target.id}:${targetId}`
                                    }
                                })
                            } else {
                                dict[sourceId].box_links = [{
                                    link: {
                                        typelink: 2,
                                        box_id: `${edge.target.id}:${targetId}`
                                    }
                                }]
                            }
                        }

                        for (const edge of cell.edges.filter(e => e.target === cell)) {
                            const sourceId = edge.value.getAttribute("sourceTd")
                            const targetId = edge.value.getAttribute("targetTd")


                            if (dict[targetId].box_links) {
                                dict[targetId].box_links.push({
                                    link: {
                                        typelink: 2,
                                        box_id: `${edge.source.id}:${sourceId}`
                                    }
                                })
                            } else {
                                dict[targetId].box_links = [{
                                    link: {
                                        typelink: 2,
                                        box_id: `${edge.source.id}:${sourceId}`
                                    }
                                }]
                            }
                        }

                        json.boxes.push(box)
                    })


                    console.log(json)
                }


                function recursiveRows(data, dict, result = []) {

                        if (data.children.length > 0 && data.children[0].tagName === 'TABLE') {
                            if (data.children[0].querySelector("table.erd> tbody").children.length > 0) {
                                const rows = []

                                for (const tr of data.children[0].querySelector("table.erd> tbody").children) {
                                    const row = new Object()
                                    row.columns = []

                                    for (const td of tr.children) {
                                        const column = recursiveRows(td, dict)

                                        row.columns.push(column)
                                    }

                                    rows.push(row)
                                }

                                return rows
                            }
                        }
                        else {
                            const column = new Object()
                            column.item = new Object()
                            column.item.caption = data.innerText
                            column.item.box_id = data.getAttribute("box_id")

                            dict[column.item.box_id] = column.item

                            return column
                        }
                }
            }
        };

        // Implements a special perimeter for table rows inside the table markup
        mxGraphView.prototype.updateFloatingTerminalPoint = function (edge, start, end, source) {
            var next = this.getNextPoint(edge, end, source);
            var div = start.text.node.getElementsByTagName('div')[2];

            var x = start.x;
            var y = start.getCenterY();


            if (div != null) {
                y = start.getCenterY() - div.scrollTop;

                if (mxUtils.isNode(edge.cell.value) && !this.graph.isCellCollapsed(start.cell)) {
                    var attr = (source) ? 'sourceTd' : 'targetTd';
                    var box_id = edge.cell.value.getAttribute(attr);

                    // HTML labels contain an outer table which is built-in
                    var td = div.querySelectorAll(`[box_id="${box_id}"]`)[0]

                    // Gets vertical center of source or target row
                    if (td != null) {
                        y = getTdY(start, td);
                        x = getTdX(start, td);
                    }
                }

                // Checks on which side of the terminal to leave
                // if (next.x > x + start.width / 2) {
                //     x += start.width;
                // }

                // Keeps vertical coordinate inside start
                var offsetTop = parseInt(div.style.top) * start.view.scale;
                y = Math.min(start.y + start.height, Math.max(start.y + offsetTop, y));

                // Updates the vertical position of the nearest point if we're not
                // dealing with a connection preview, in which case either the
                // edgeState or the absolutePoints are null
                if (edge != null && edge.absolutePoints != null) {
                    next.y = y;
                }
            }

            edge.setAbsoluteTerminalPoint(new mxPoint(x, y), source);

            // Routes multiple incoming edges along common waypoints if
            // the edges have a common target row
            if (source && mxUtils.isNode(edge.cell.value) && start != null && end != null) {
                var edges = this.graph.getEdgesBetween(start.cell, end.cell, true);
                var tmp = [];

                // Filters the edges with the same source row
                var row = edge.cell.value.getAttribute('targetTd');

                for (var i = 0; i < edges.length; i++) {
                    if (mxUtils.isNode(edges[i].value) &&
                        edges[i].value.getAttribute('targetTd') == row) {
                        tmp.push(edges[i]);
                    }
                }

                edges = tmp;

                if (edges.length > 1 && edge.cell == edges[edges.length - 1]) {
                    // Finds the vertical center
                    var states = [];
                    var y = 0;

                    for (var i = 0; i < edges.length; i++) {
                        states[i] = this.getState(edges[i]);
                        y += states[i].absolutePoints[0].y;
                    }

                    y /= edges.length;

                    for (var i = 0; i < states.length; i++) {
                        var x = states[i].absolutePoints[1].x;

                        if (states[i].absolutePoints.length < 5) {
                            states[i].absolutePoints.splice(2, 0, new mxPoint(x, y));
                        } else {
                            states[i].absolutePoints[2] = new mxPoint(x, y);
                        }

                        // Must redraw the previous edges with the changed point
                        if (i < states.length - 1) {
                            this.graph.cellRenderer.redraw(states[i]);
                        }
                    }
                }
            }
        };

        // Defines global helper function to get y-coordinate for a given cell state and row
        const getTdY = function (state, td) {
            var s = state.view.scale;
            var div = getParentDiv(td);

            let offset = getOffsetValues(td, div)

            var y = state.y + (offset.y + td.offsetHeight / 2 - div.scrollTop + div.offsetTop) * s;
            y = Math.min(state.y + state.height, Math.max(state.y + div.offsetTop * s, y));

            return y;
        };

        const getTdX = function (state, td) {
            var s = state.view.scale;
            var div = getParentDiv(td);

            let offset = getOffsetValues(td, div)


            var x = state.x + (offset.x + td.offsetWidth / 2) * s;
            x = Math.min(state.x + state.width, Math.max(state.x, x));

            return x;
        };

        const getParentDiv = function (target) {
            while (target != null && target.nodeName != 'DIV') {
                target = target.parentNode;
            }
            return target
        }

        const getOffsetValues = function (elem, parent) {
            let x = 0;
            let y = 0;
            let elemTmp = elem;

            while (elemTmp !== parent) {
                x += elemTmp.offsetLeft;
                y += elemTmp.offsetTop;

                elemTmp = elemTmp.offsetParent;
            }

            return {x: x, y: y}
        }
    </script>
</head>

<!-- Page passes the container for the graph to the program -->
<body onload="main(document.getElementById('graphContainer'))">

<!-- Creates a container for the graph with a grid wallpaper. Width, height and cursor in the style are for IE only -->
<div id="graphContainer"
     style="cursor:default;position:absolute;top:30px;left:0px;bottom:0px;right:0px;background:url('editors/images/grid.gif')">
</div>

<button style="top: 500px" id="log_button">
    Log JSON
</button>

</body>
</html>
