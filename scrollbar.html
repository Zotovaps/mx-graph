<html>
<head>
    <title>Scrollbars example for mxGraph</title>

    <style type="text/css" media="screen">

        ::-webkit-scrollbar {
            width: 4px; /* width of the entire scrollbar */
            height: 10px; /* width of the entire scrollbar */
        }

        ::-webkit-scrollbar-track {
            background: #E8EAF1;; /* color of the tracking area */
        }

        ::-webkit-scrollbar-thumb {
            background-color: #B7BDD0; /* color of the scroll thumb */
            border-radius: 20px; /* roundness of the scroll thumb */
            /*border: 3px solid orange; !* creates padding around scroll thumb *!*/
        }

        table.title th {
            font-size: 10pt;
            font-family: Verdana;
            white-space: nowrap;
            background: lightgray;
            font-weight: bold;
        }

        table.erd {
            font-size: 10pt;
            font-family: Verdana;
            border-color: black;
            border-collapse: collapse;
            overflow: auto;
            cursor: move;
            white-space: nowrap;
        }

        table.erd td {
            border-color: black;
            text-align: left;
            color: black;
        }


        table.erd > tbody td {
            padding: 0 10px;
        }

        table.erd > tbody tr:nth-child(odd) {
            background-color: #F7F8FC;
        }

        table.erd > tbody tr:nth-child(even) {
            background-color: #FFFFFF;

        }

        button {
            position: absolute;
        }

        ul {
            padding: 0;
            margin: 0;
        }

        li {
            list-style: none;
            height: 48px;
            display: flex;
            align-items: center;
        }

        li:hover {
            background: #C0C0C0;
        }


        .typography-h2 {
            /*font-family: Inter;*/
            font-size: 16px;
            font-style: normal;
            font-weight: 600;
            line-height: 19px;

            color: #3F4864;
        }


        .collapsed-cell {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 5px;

            box-sizing: border-box;
            width: 100%;
            height: 100%;
            padding: 10px 10px 10px 20px;

            border-radius: 30px;
            background: #0A1650;
            box-shadow: 1px 1px 2px 0px rgba(52, 65, 113, 0.10);


        }

        .collapsed-cell > .typography-h2 {
            color: #FFFFFF;
        }


        .cell-container {
            position: absolute;
            top: 0;
            bottom: 0;

            display: flex;
            flex-direction: column;
            gap: 10px;

            box-sizing: border-box;
            width: 100%;
            padding: 10px;

            cursor: default;
        }

        .cell-header {
            width: 100%;
            height: 24px;

            overflow: hidden;
        }

        .cell-container > ul {

            box-sizing: border-box;
            width: 100%;
            height: 100%;

            overflow: auto;
            flex: 1;
        }
    </style>

    <!-- Sets the basepath for the library if not in same directory -->
    <script type="text/javascript">
        mxBasePath = '../src';
    </script>

    <!-- Loads and initializes the library -->
    <script type="text/javascript" src="../src/js/mxClient.js"></script>
    <script type="text/javascript" src="../js/custom.js"></script>

    <!-- Example code -->
    <script type="text/javascript">
        // Program starts here. Creates a sample graph in the
        // DOM node with the specified ID. This function is invoked
        // from the onLoad event handler of the document (see below).
        function main(container) {
            // Checks if the browser is supported
            if (!mxClient.isBrowserSupported()) {
                // Displays an error message if the browser is not supported.
                mxUtils.error('Browser is not supported!', 200, false);
            } else {
                // Must be disabled to compute positions inside the DOM tree of the cell label.
                mxGraphView.prototype.optimizeVmlReflows = false;

                // If connect preview is not moved away then getCellAt is used to detect the cell under
                // the mouse if the mouse is over the preview shape in IE (no event transparency), ie.
                // the built-in hit-detection of the HTML document will not be used in this case. This is
                // not a problem here since the preview moves away from the mouse as soon as it connects
                // to any given table row. This is because the edge connects to the outside of the row and
                // is aligned to the grid during the preview.
                mxConnectionHandler.prototype.movePreviewAway = false;

                // Disables foreignObjects
                mxClient.NO_FO = true;

                // Enables move preview in HTML to appear on top
                mxGraphHandler.prototype.htmlPreview = true;

                // Enables connect icons to appear on top of HTML
                mxConnectionHandler.prototype.moveIconFront = true;

                // Defines an icon for creating new connections in the connection handler.
                // This will automatically disable the highlighting of the source vertex.
                mxConnectionHandler.prototype.connectImage = new mxImage('src/images/connector.gif', 16, 16);

                // Support for certain CSS styles in quirks mode
                if (mxClient.IS_QUIRKS) {
                    new mxDivResizer(container);
                }

                // Disables the context menu
                mxEvent.disableContextMenu(container);

                // Overrides target perimeter point for connection previews
                mxConnectionHandler.prototype.getTargetPerimeterPoint = function (state, me) {
                    // Determines the y-coordinate of the target perimeter point
                    // by using the currentRowNode assigned in updateRow
                    var y = me.getY();

                    if (this.currentRowNode != null) {
                        y = getRowY(state, this.currentRowNode);
                    }

                    // Checks on which side of the terminal to leave
                    var x = state.x;

                    if (this.previous.getCenterX() > state.getCenterX()) {
                        x += state.width;
                    }

                    return new mxPoint(x, y);
                };

                // Overrides source perimeter point for connection previews
                mxConnectionHandler.prototype.getSourcePerimeterPoint = function (state, next, me) {
                    var y = me.getY();

                    if (this.sourceRowNode != null) {
                        y = getRowY(state, this.sourceRowNode);
                    }

                    // Checks on which side of the terminal to leave
                    var x = state.x;

                    if (next.x > state.getCenterX()) {
                        x += state.width;
                    }

                    return new mxPoint(x, y);
                };

                // Disables connections to invalid rows
                mxConnectionHandler.prototype.isValidTarget = function (cell) {
                    return this.currentRowNode != null;
                };

                // Creates the graph inside the given container
                var graph = new mxGraph(container);

                function updateStyle(state, hover) {
                    if (state.cell.collapsed) {
                        // state.style[mxConstants.STYLE_ARCSIZE] = "60";

                        // if (hover) {
                        //     state.style[mxConstants.STYLE_STROKEWIDTH] = '4';
                        //     state.style[mxConstants.STYLE_STROKECOLOR] = '#ff0000';
                        // }
                    } else {
                        if (hover) {
                            state.style[mxConstants.STYLE_STROKEWIDTH] = '2';
                            state.style[mxConstants.STYLE_STROKECOLOR] = '#2D49D7';
                        }
                    }
                }

                graph.addMouseListener({
                    currentState: null,
                    previousStyle: null,
                    mouseDown: function (sender, me) {
                        if (this.currentState != null) {
                            this.dragLeave(me.getEvent(), this.currentState);
                            this.currentState = null;
                        }
                    },
                    mouseMove: function (sender, me) {
                        if (this.currentState != null && me.getState() == this.currentState) {
                            return;
                        }

                        var tmp = graph.view.getState(me.getCell());

                        // Ignores everything but vertices
                        if (graph.isMouseDown || (tmp != null && !graph.getModel().isVertex(tmp.cell))) {
                            tmp = null;
                        }

                        if (tmp != this.currentState) {
                            if (this.currentState != null) {
                                this.dragLeave(me.getEvent(), this.currentState);
                            }

                            this.currentState = tmp;

                            if (this.currentState != null) {
                                this.dragEnter(me.getEvent(), this.currentState);
                            }
                        }
                    },
                    mouseUp: function (sender, me) {
                    },
                    dragEnter: function (evt, state) {
                        if (state != null) {
                            this.previousStyle = state.style;
                            state.style = mxUtils.clone(state.style);
                            updateStyle(state, true);
                            state.shape.apply(state);
                            state.shape.redraw();

                            if (state.text != null) {
                                state.text.apply(state);
                                state.text.redraw();
                            }
                        }
                    },
                    dragLeave: function (evt, state) {
                        if (state != null) {
                            state.style = this.previousStyle;
                            updateStyle(state, false);
                            state.shape.apply(state);
                            state.shape.redraw();

                            if (state.text != null) {
                                state.text.apply(state);
                                state.text.redraw();
                            }
                        }
                    }
                });

                graph.addListener(mxEvent.CELLS_MOVED, function (sender, evt) {
                    var cell = evt.getProperties("cell");
                    console.log(cell.cells[0], cell.cells[0].geometry.x, cell.cells[0].geometry.y, "Cell was moved");
                });

                graph.addListener(mxEvent.CELLS_RESIZED, function (sender, evt) {
                    var cell = evt.getProperties("cell");
                    console.log(cell.cells[0], cell.cells[0].geometry.width, cell.cells[0].geometry.height, "Cell was resized");
                });


                //Collapsed/ icon override
                graph.collapsedImage = new mxImage('./icons/arrow-right.svg', 24, 24);
                graph.expandedImage = new mxImage('./icons/arrow-left.svg', 24, 24);


                // Использует периметр объекта (ниже) по умолчанию
                // (Uses the entity perimeter (below) as default)
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_LEFT;
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_PERIMETER] = mxPerimeter.EntityPerimeter;
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_FILLCOLOR] = '#FFFFFF';
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_STROKECOLOR] = '#D2D7E3';
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_STROKEWIDTH] = 1;
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_ROUNDED] = 1;
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_ABSOLUTE_ARCSIZE] = 1;
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_ARCSIZE] = "16";
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_FONTSIZE] = "14";
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_FONTCOLOR] = "#24293D";


                // Используется для меток HTML, которые занимают все пространство вершин
                // (см. graph.cellRenderer.redrawLabel ниже для синхронизации размера)
                graph.stylesheet.getDefaultVertexStyle()[mxConstants.STYLE_OVERFLOW] = 'fill';


                // Использует стиль ребра объекта по умолчанию
                // (Uses the entity edge style as default)
                mxMarker.addMarker('custom', function (canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {
                    var a = size / 2;

                    var pt = pe.clone();
                    pe.x -= unitX * a;
                    pe.y -= unitY * a;

                    return function () {
                        canvas.state.fillColor = "#FFFFFF"
                        canvas.state.strokeWidth = 3

                        canvas.ellipse(pt.x - a, pt.y - a, size, size);

                        if (filled) {
                            canvas.fillAndStroke();
                        } else {
                            canvas.stroke();
                        }
                    };
                })

                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_CONNECTOR;
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_ROUNDED] = 1;
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_STROKECOLOR] = '#2D49D7';
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_FONTCOLOR] = '#446299';
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_STROKEWIDTH] = 2;
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_ENDSIZE] = 15;
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_STARTSIZE] = 15;
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_ENDARROW] = 'custom';
                graph.stylesheet.getDefaultEdgeStyle()[mxConstants.STYLE_STARTARROW] = 'custom';


                // Позволяет устанавливать новые соединения,
                // но не разрешает изменять существующие соединения
                graph.setCellsDisconnectable(false);
                graph.setAllowDanglingEdges(false);
                graph.setCellsEditable(false);
                graph.setConnectable(true);
                graph.setPanning(true);
                graph.centerZoom = false;


                // Переопределить свертывание, чтобы разрешить таблицы
                // (Override folding to allow for tables)
                graph.isCellFoldable = function (cell, collapse) {
                    return this.getModel().isVertex(cell);
                };

                // Overrides connectable state
                graph.isCellConnectable = function (cell) {
                    return !this.isCellCollapsed(cell);
                };

                // Enables HTML markup in all labels
                graph.setHtmlLabels(true);

                // Scroll events should not start moving the vertex
                graph.cellRenderer.isLabelEvent = function (state, evt) {
                    var source = mxEvent.getSource(evt);

                    return state.text != null && source != state.text.node &&
                        source != state.text.node.getElementsByTagName('div')[0];
                };

                // Adds scrollbars to the outermost div and keeps the
                // DIV position and size the same as the vertex
                var oldRedrawLabel = graph.cellRenderer.redrawLabel;
                graph.cellRenderer.redrawLabel = function (state) {
                    oldRedrawLabel.apply(this, arguments); // "supercall"
                    var graph = state.view.graph;
                    var model = graph.model;

                    if (model.isVertex(state.cell) && state.text != null) {
                        // Scrollbars are on the div
                        var s = graph.view.scale;
                        var div = state.cell.isCollapsed() ? state.text.node.getElementsByTagName('div')[2] : state.text.node.getElementsByTagName('div')[2].getElementsByClassName("erd")[0];

                        console.log(state.cell.isCollapsed(), "sss")

                        if (div != null) {
                            // Installs the handler for updating connected edges
                            if (div.scrollHandler == null) {
                                div.scrollHandler = true;

                                var updateEdges = mxUtils.bind(this, function () {
                                    var edgeCount = model.getEdgeCount(state.cell);

                                    // Only updates edges to avoid update in DOM order
                                    // for text label which would reset the scrollbar
                                    for (var i = 0; i < edgeCount; i++) {
                                        var edge = model.getEdgeAt(state.cell, i);
                                        graph.view.invalidate(edge, true, false);
                                        graph.view.validate(edge);
                                    }
                                });

                                mxEvent.addListener(div, 'scroll', updateEdges);
                                mxEvent.addListener(div, 'mouseup', updateEdges);
                            }
                        }
                    }
                };


                // Adds a new function to update the currentRow based on the given event
                // and return the DOM node for that row
                graph.connectionHandler.updateRow = function (target) {
                    while (target != null && target.nodeName !== 'DIV' &&
                    target.nodeName !== 'LI' && target.nodeName !== 'TR' &&
                    target.nodeName !== 'svg' && target.nodeName !== 'UL' &&
                    target.nodeName !== 'IMG' && target.nodeName !== 'TABLE') {

                        target = target.parentNode;
                    }

                    this.currentRow = null;

                    // Checks if we're dealing with a row in the correct table
                    if (target != null && target.parentNode.className == 'erd' || target.parentNode.parentNode.className == 'erd') {
                        // Stores the current row number in a property so that it can
                        // be retrieved to create the preview and final edge
                        var rowNumber = 0;
                        var current = target.parentNode.firstChild;

                        while (target != current && current != null) {
                            current = current.nextSibling;
                            rowNumber++;
                        }

                        this.currentRow = rowNumber + 1;
                    } else {
                        target = null;
                    }

                    return target;
                };


                // Adds placement of the connect icon based on the mouse event target (row)
                graph.connectionHandler.updateIcons = function (state, icons, me) {
                    var target = me.getSource();
                    target = this.updateRow(target);

                    if (target != null && this.currentRow != null) {
                        var div = target.parentNode;
                        var s = state.view.scale;

                        icons[0].node.style.visibility = 'visible';
                        icons[0].bounds.x = state.x + target.offsetLeft + Math.min(state.width,
                            target.offsetWidth * s) - this.icons[0].bounds.width - 2;
                        icons[0].bounds.y = state.y - this.icons[0].bounds.height / 2 + (target.offsetTop +
                            target.offsetHeight / 2 - div.scrollTop) * s;
                        icons[0].redraw();


                        this.currentRowNode = target;
                    } else {
                        icons[0].node.style.visibility = 'hidden';
                    }
                };

                // Updates the targetRow in the preview edge State
                var oldMouseMove = graph.connectionHandler.mouseMove;
                graph.connectionHandler.mouseMove = function (sender, me) {
                    if (this.edgeState != null) {
                        this.currentRowNode = this.updateRow(me.getSource());

                        if (this.currentRow != null) {
                            this.edgeState.cell.value.setAttribute('targetRow', this.currentRow);
                        } else {
                            this.edgeState.cell.value.setAttribute('targetRow', '0');
                        }

                        // Destroys icon to prevent event redirection via image in IE
                        this.destroyIcons();
                    }

                    oldMouseMove.apply(this, arguments);
                };

                // Creates the edge state that may be used for preview
                graph.connectionHandler.createEdgeState = function (me) {
                    var relation = doc.createElement('Relation');
                    relation.setAttribute('sourceRow', this.currentRow || '0');
                    relation.setAttribute('targetRow', '0');

                    var edge = this.createEdge(relation);
                    var style = this.graph.getCellStyle(edge);
                    var state = new mxCellState(this.graph.view, edge, style);

                    // Stores the source row in the handler
                    this.sourceRowNode = this.currentRowNode;

                    return state;
                };


                // Переопределяет getLabel, чтобы возвращать пустые метки для ребер и
                // короткую разметку для свернутых ячеек.
                graph.getLabel = function (cell) {
                    if (this.getModel().isVertex(cell)) {

                        if (this.isCellCollapsed(cell)) {
                            var collapsedCellHtml =
                                `<ul class="collapsed-cell">` +
                                `<li class="typography-h2">${cell.value.header.caption}</li>` +
                                `</ul>`

                            return collapsedCellHtml

                        } else {

                            if (cell.value.body.json) {
                                // var cellHtml = `<ul class="cell-header">` +
                                //     `<li class="typography-h2">${cell.value.header.caption}</li>` +
                                //     `</ul>` +
                                //     '<div style="overflow:auto;cursor:default;top:26px;bottom:0px;position:absolute;width:100%;">'+
                                //     '<ul style="width:100%; height: 100%; text-align: start; padding: 5px 10px; box-sizing: border-box" class="erd">'

                                var cellHtml = '<div class="cell-container">' +
                                    `<div class="cell-header">` +
                                    `<span class="typography-h2">${cell.value.header.caption}</span>` +
                                    '</div>' +
                                    '<ul class="erd">'

                                Object.keys(cell.value.body.json).forEach(key => {
                                    cellHtml += drawJson(key, cell.value.body.json[key]);
                                })

                                cellHtml += '</ul></div>';

                                return cellHtml;
                            } else if (cell.value.body.rows) {
                                // var cellHtml = '<table style="overflow:hidden;" width="100%" border="1" cellpadding="4" class="title">' +
                                //     `<tr><th colspan="2">${cell.value.header.caption}</th></tr>` +
                                //     '</table>' +
                                //     '<div style="overflow:auto;cursor:default;top:26px;bottom:0px;position:absolute;width:100%;">' +
                                //     '<table width="100%" height="100%" border="1" cellpadding="4" class="erd">';


                                var cellHtml = '<div class="cell-container">' +
                                    `<div class="cell-header">` +
                                    `<span class="typography-h2">${cell.value.header.caption}</span>` +
                                    '</div>' +
                                    '<table width="100%" height="100%" class="erd">'


                                cell.value.body.rows.forEach(item => {
                                    cellHtml += `<tr>`

                                    item.columns.forEach(item2 => {
                                        cellHtml += `<td>${item2.item.caption}</td>`
                                    })

                                    cellHtml += `</tr>`
                                })

                                cellHtml += '</table>'

                                return cellHtml
                            }
                        }
                    } else {
                        return '';
                    }
                };

                // User objects (data) for the individual cells
                var doc = mxUtils.createXmlDocument();
                //
                // // Same should be used to create the XML node for the table
                // // description and the rows (most probably as child nodes)
                // var relation = doc.createElement('Relation');
                // relation.setAttribute('sourceRow', '4');
                // relation.setAttribute('targetRow', '6');

                // Enables rubberband selection
                new mxRubberband(graph);

                // Enables key handling (eg. escape)
                new mxKeyHandler(graph);

                // Gets the default parent for inserting new cells. This
                // is normally the first child of the root (ie. layer 0).
                var parent = graph.getDefaultParent();


                // Adds cells to the model in a single step
                graph.getModel().beginUpdate();
                try {

                    var data = {
                        "boxes": [
                            {
                                "id": "box_rows_columns_example",
                                "header": {
                                    "caption": "Test",
                                    "position": {
                                        "top": 10,
                                        "left": 10
                                    },
                                    "size": {
                                        "width": 345,
                                        "height": 523
                                    }
                                },
                                "body": {
                                    "rows": [
                                        {
                                            "columns": [
                                                {
                                                    "item": {
                                                        "box_id": "item1",
                                                        "caption": "aaa",
                                                        "box_links": [
                                                            {
                                                                "link": {
                                                                    "typelink": 1,
                                                                    "box_id": "box_json_example:item1"
                                                                }
                                                            }
                                                        ]
                                                    }
                                                }
                                            ]
                                        }
                                    ]
                                }
                            },
                            {
                                "id": "box_json_example",
                                "header": {
                                    "caption": "Test2",
                                    "position": {
                                        "top": 10,
                                        "left": 500
                                    },
                                    "size": {
                                        "width": 345,
                                        "height": 523
                                    }
                                },
                                "body": {
                                    "json": {
                                        "type": "basket",
                                        "beans": 47,
                                        "apples": 7,
                                        "oranges": 23,
                                        "brand": "ConvertSimple",
                                        "ratio": {
                                            "box_id": "item1"
                                        },
                                        "fees": {
                                            "cleaning": "$4.50",
                                            "baking": "$27.30",
                                            "commission": {
                                                "box_links": [
                                                    {
                                                        "link": {
                                                            "typelink": 2,
                                                            "box_id": "box_rows_columns_example:item1"
                                                        }
                                                    }
                                                ]
                                            },
                                            "descriptors": [
                                                "clean",
                                                "fresh",
                                                "juicy",
                                                "delicious"
                                            ]
                                        }
                                    }
                                }
                            },

                        ]
                    }

                    data.boxes.forEach((item, index) => {
                        let vertex = graph.insertVertex(parent, item.id, item, item.header.position.left,
                            item.header.position.top, item.header.size.width, item.header.size.height);

                        vertex.geometry.alternateBounds = new mxRectangle(0, 0, item.header.size.width, 44);
                    })


                    var verticesEdge = []
                    var indexRow = 0
                    var jsonList = []
                    var vertices = graph.getChildVertices(parent);


                    const recursiveJson = function (key, data, id) {
                        indexRow++
                        if (typeof (data) === "object") {

                            Object.keys(data).forEach(k => {
                                if (k !== "box_links")
                                    recursiveJson(k, data[k], id)
                                else {
                                    data[k].forEach(link => {
                                        let box_id = link.link.box_id.split(":");

                                        let vert = vertices.find(v => v.id === box_id[0])


                                        jsonList.push({targetId: box_id[0], targetRow: 1, sourceId: id, sourceRow: indexRow})
                                    })
                                }
                            })
                        } else {
                            return
                        }
                    }

                    vertices.forEach((item, index) => {
                        indexRow = 0
                        if (item.value.body.json) {


                            Object.keys(item.value.body.json).forEach(k => {
                                recursiveJson(k, item.value.body.json[k], item.id)
                            })

                            console.log(jsonList, "jsonList")
                        }

                    })

                    jsonList.forEach(item => {
                        var relation = doc.createElement('Relation');
                        relation.setAttribute('sourceRow', item.sourceRow);
                        relation.setAttribute('targetRow', item.targetRow);

                        graph.insertEdge(parent, null, relation,
                            vertices.find(v => v.id === item.sourceId), vertices.find(v => v.id === item.targetId));

                    })

                } finally {
                    // Updates the display
                    graph.getModel().endUpdate();
                }

                // var btn1 = mxUtils.button('+', function () {
                //     graph.zoomIn();
                // });
                // btn1.style.marginLeft = '20px';
                //
                // document.body.appendChild(btn1);
                // document.body.appendChild(mxUtils.button('-', function () {
                //     graph.zoomOut();
                // }));
            }
        }


        // Implements a special perimeter for table rows inside the table markup
        mxGraphView.prototype.updateFloatingTerminalPoint = function (edge, start, end, source) {

            var next = this.getNextPoint(edge, end, source);
            var div = start.text.node.getElementsByTagName('div')[2];

            var x = start.x;
            var y = start.getCenterY();

            // Checks on which side of the terminal to leave
            if (next.x > x + start.width / 2) {
                x += start.width;
            }

            if (div != null) {
                y = start.getCenterY() - div.scrollTop;

                if (mxUtils.isNode(edge.cell.value) && !this.graph.isCellCollapsed(start.cell)) {
                    var attr = (source) ? 'sourceRow' : 'targetRow';
                    var row = parseInt(edge.cell.value.getAttribute(attr));

                    // HTML labels contain an outer table which is built-in

                    var element
                    // var parent

                    if (div.getElementsByTagName('ul')[0]) {
                        // parent = div.getElementsByTagName('ul')[0];
                        var ul = div.getElementsByTagName('ul')[0];
                        var lis = ul.getElementsByTagName('li');
                        element = lis[Math.min(lis.length - 1, row - 1)];
                    } else {
                        // parent = div.getElementsByTagName('table')[0];
                        var table = div.getElementsByTagName('table')[0];
                        var trs = table.getElementsByTagName('tr');
                        element = trs[Math.min(trs.length - 1, row - 1)];
                    }


                    // Gets vertical center of source or target row
                    if (element != null) {
                        y = getRowY(start, element);
                    }
                }

                // Keeps vertical coordinate inside start
                // var offsetTop = parseInt(div.style.top) * start.view.scale; Error with new HTML
                // var offsetTop = parseInt(parent.offsetTop) * start.view.scale;
                var offsetTop = parseInt(div.offsetTop) * start.view.scale;

                y = Math.min(start.y + start.height, Math.max(start.y + offsetTop, y));

                console.log(y, start.y, offsetTop, "ERROR")

                // Updates the vertical position of the nearest point if we're not
                // dealing with a connection preview, in which case either the
                // edgeState or the absolutePoints are null
                if (edge != null && edge.absolutePoints != null) {
                    next.y = y;
                }
            }

            edge.setAbsoluteTerminalPoint(new mxPoint(x, y), source);


            // Routes multiple incoming edges along common waypoints if
            // the edges have a common target row
            if (source && mxUtils.isNode(edge.cell.value) && start != null && end != null) {
                var edges = this.graph.getEdgesBetween(start.cell, end.cell, true);
                var tmp = [];

                // Filters the edges with the same source row
                var row = edge.cell.value.getAttribute('targetRow');

                for (var i = 0; i < edges.length; i++) {
                    if (mxUtils.isNode(edges[i].value) &&
                        edges[i].value.getAttribute('targetRow') == row) {
                        tmp.push(edges[i]);
                    }
                }

                edges = tmp;

                if (edges.length > 1 && edge.cell == edges[edges.length - 1]) {
                    // Finds the vertical center
                    var states = [];
                    var y = 0;

                    for (var i = 0; i < edges.length; i++) {
                        states[i] = this.getState(edges[i]);
                        y += states[i].absolutePoints[0].y;
                    }

                    y /= edges.length;

                    for (var i = 0; i < states.length; i++) {
                        var x = states[i].absolutePoints[1].x;

                        if (states[i].absolutePoints.length < 5) {
                            states[i].absolutePoints.splice(2, 0, new mxPoint(x, y));
                        } else {
                            states[i].absolutePoints[2] = new mxPoint(x, y);
                        }

                        // Must redraw the previous edges with the changed point
                        if (i < states.length - 1) {
                            this.graph.cellRenderer.redraw(states[i]);
                        }
                    }
                }
            }
        };


        // Определяет глобальную вспомогательную функцию для получения координаты Y для заданного состояния ячейки и строки.
        const getRowY = function (state, elem) {
            var s = state.view.scale;

            if (elem.nodeName === 'LI') {
                var div = elem.parentNode;
                // Была ошибка после изменения HTML
                // var offsetTop = parseInt(div.offsetTop);
                // var y = state.y + (elem.offsetTop + elem.offsetHeight / 2 - div.scrollTop + offsetTop) * s;
                // y = Math.min(state.y + state.height, Math.max(state.y + offsetTop * s, y));
                var y = state.y + (elem.offsetTop + elem.offsetHeight / 2 - div.scrollTop) * s;
                y = Math.min(state.y + state.height, Math.max(state.y * s, y));

                console.log(elem.offsetTop)
                return y;
            }

            if (elem.nodeName === 'TR') {
                var div = elem.parentNode.parentNode;
                // Была ошибка после изменения HTML
                // var offsetTop = parseInt(div.offsetTop);
                // var y = state.y + (elem.offsetTop + elem.offsetHeight / 2 - div.scrollTop + offsetTop) * s;
                // y = Math.min(state.y + state.height, Math.max(state.y + offsetTop * s, y));
                var y = state.y + (elem.offsetTop + elem.offsetHeight / 2 - div.scrollTop) * s;
                y = Math.min(state.y + state.height, Math.max(state.y * s, y));

                console.log(elem.offsetTop)
                return y;
            }
        };


        // Рекурсивная функция генерации DOM по JSON
        const drawJson = function (key, data, level = 0, html = "") {
            if (typeof (data) === "object") {
                html += `<li style="margin-left: calc(10px * ${level})"><span>${key}:</span></li>`
                Object.keys(data).forEach(k => {
                    if (k !== "box_links")
                        html += drawJson(k, data[k], level + 1)
                })
                return html
            } else {
                return `<li style="margin-left: calc(10px * ${level})"> <span>${key}:${data}</span></li>`
            }
        }

    </script>
</head>

<!-- Страница передает контейнер для графа в программу -->
<body onload="main(document.getElementById('graphContainer'))">

<!-- Создает контейнер для графика с обоями сетки. Ширина, высота и курсор в стиле только для IE -->
<div id="graphContainer"
     style="cursor:default;position:absolute;top:30px;left:0px;bottom:0px;right:0px;">
</div>
</body>
</html>
